```go
import (
	"fmt"
	"log"
	"gonum.org/v1/gonum/mat"
)
```

### üîπ –£—Ä–æ–∫ 1: –õ–∏–Ω–µ–π–Ω–∞—è –∞–ª–≥–µ–±—Ä–∞ ‚Äî –≤–µ–∫—Ç–æ—Ä—ã –∏ —Å–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ

#### üìò –¢–µ–æ—Ä–∏—è:

–í–µ–∫—Ç–æ—Ä ‚Äî —ç—Ç–æ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä —á–∏—Å–µ–ª, –Ω–∞–ø—Ä–∏–º–µ—Ä:
`A = [1, 2, 3]` ‚Äî –≤–µ–∫—Ç–æ—Ä –≤ 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ.

–°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (dot product) –¥–≤—É—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤:

```text
A ‚Ä¢ B = A‚ÇÅ*B‚ÇÅ + A‚ÇÇ*B‚ÇÇ + A‚ÇÉ*B‚ÇÉ
```

–ï—Å–ª–∏ —É–≥–æ–ª –º–µ–∂–¥—É –Ω–∏–º–∏ –æ—Å—Ç—Ä—ã–π ‚Üí —Å–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ.
–ï—Å–ª–∏ –ø—Ä—è–º–æ–π —É–≥–æ–ª ‚Üí –Ω–æ–ª—å.
–ï—Å–ª–∏ —Ç—É–ø–æ–π —É–≥–æ–ª ‚Üí –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ.


```go
import (
	"fmt"
	"log"
)

func dotProduct(a, b []float64) float64 {
	if len(a) != len(b) {
		log.Fatal("–í–µ–∫—Ç–æ—Ä—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–∞–≤–Ω—ã")
	}
	var product float64
	for i := 0; i < len(a); i++ {
		product += a[i] * b[i]
	}
	return product
}
```


```go
vec1 := []float64{1, 2, 3}
vec2 := []float64{4, 5, 6}
fmt.Println("–°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ:", dotProduct(vec1, vec2))
```

### üîπ –£—Ä–æ–∫ 2: –ú–∞—Ç—Ä–∏—Ü—ã –∏ —É–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü

---

#### üìò –¢–µ–æ—Ä–∏—è:

**–ú–∞—Ç—Ä–∏—Ü–∞** ‚Äî —ç—Ç–æ —Ç–∞–±–ª–∏—Ü–∞ —á–∏—Å–µ–ª, –Ω–∞–ø—Ä–∏–º–µ—Ä:

```
A =  | 1  2 |
     | 3  4 |

B =  | 5  6 |
     | 7  8 |
```

–ß—Ç–æ–±—ã –ø–µ—Ä–µ–º–Ω–æ–∂–∏—Ç—å –¥–≤–µ –º–∞—Ç—Ä–∏—Ü—ã `A` –∏ `B`, –Ω—É–∂–Ω–æ:

* –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ **—Å—Ç–æ–ª–±—Ü–æ–≤ –≤ A** –¥–æ–ª–∂–Ω–æ = –∫–æ–ª–∏—á–µ—Å—Ç–≤—É **—Å—Ç—Ä–æ–∫ –≤ B**.
* –†–µ–∑—É–ª—å—Ç–∞—Ç ‚Äî –Ω–æ–≤–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞–∑–º–µ—Ä–æ–º `(—Å—Ç—Ä–æ–∫–∏ A) x (—Å—Ç–æ–ª–±—Ü—ã B)`.

–ö–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∫–∞–∫ **—Å–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ** —Å—Ç—Ä–æ–∫–∏ `A` –∏ —Å—Ç–æ–ª–±—Ü–∞ `B`.



```go
func multiplyMatrices(a, b [][]float64) [][]float64 {
	rowsA := len(a)
	rowsB := len(b)
	colsA := len(a[0])
	colsB := len(b[0])

	if colsA != rowsB {
		log.Fatal("–ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ –º–∞—Ç—Ä–∏—Ü")
	}

	result := make([][]float64, rowsA)
	for i := range result {
		result[i] = make([]float64, colsB)
	}

	for i := 0; i < rowsA; i++ {
		for j := 0; j < colsB; j++ {
			var sum float64
			for k := 0; k < colsA; k++ {
				sum += a[i][k] * b[k][j]
			}
			result[i][j] = sum
		}
	}
	return result
}

a := [][]float64{
	{1, 2},
	{3, 4},
	{12, 9},
	{11, 13},
}

b := [][]float64{
	{5, 6, 12, 9},
	{7, 8, 11, 10},
}

result := multiplyMatrices(a, b)

fmt.Println("–†–µ–∑—É–ª—å—Ç–∞—Ç —É–º–Ω–æ–∂–µ–Ω–∏—è:")
for _, row := range result {
	fmt.Println(row)
}
```

### üîπ –£—Ä–æ–∫ 3: –†–∞–±–æ—Ç–∞ —Å `gonum/mat` ‚Äî –±–∞–∑–æ–≤—ã–µ –≤–µ–∫—Ç–æ—Ä—ã –∏ –º–∞—Ç—Ä–∏—Ü—ã

---

#### üìò –¢–µ–æ—Ä–∏—è:

[`gonum/mat`](https://pkg.go.dev/gonum.org/v1/gonum/mat) ‚Äî —ç—Ç–æ –æ—Å–Ω–æ–≤–Ω–æ–π –ø–∞–∫–µ—Ç –¥–ª—è –ª–∏–Ω–µ–π–Ω–æ–π –∞–ª–≥–µ–±—Ä—ã –≤ Go.

–í –Ω—ë–º –µ—Å—Ç—å:

* `mat.NewVecDense` ‚Äî —Å–æ–∑–¥–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞.
* `mat.NewDense` ‚Äî —Å–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã.
* –ú–µ—Ç–æ–¥—ã –≤—Ä–æ–¥–µ `Dot`, `Mul`, `T()` ‚Äî –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π.





```go
package main

import (
	"fmt"
	"gonum.org/v1/gonum/mat"
)

func main() {
	a := mat.NewVecDense(3, []float64{1, 2, 3})
	b := mat.NewVecDense(3, []float64{4, 5, 6})
	dot := mat.Dot(a, b)
	fmt.Println("–°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ:", dot)

	m1 := mat.NewDense(2, 3, []float64{
		1, 2, 3,
		4, 5, 6,
	})
	m2 := mat.NewDense(3, 2, []float64{
		7, 8,
		9, 10,
		11, 12,
	})

	var result mat.Dense
	result.Mul(m1, m2)

	fmt.Println("–£–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü m1 * m2:")
	fmt.Printf("%v\n", mat.Formatted(&result, mat.Prefix(""), mat.Excerpt(0)))
}

main()

```
---

### üîπ –£—Ä–æ–∫ 4: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å `gonum/stat` 

---

#### üìò –¢–µ–æ—Ä–∏—è: –æ—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ 

–î–ª—è –º–∞—à–∏–Ω–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –Ω–∞–º –Ω—É–∂–Ω—ã:

| –ú–µ—Ç—Ä–∏–∫–∞         | –ß—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç                   |
| --------------- | ------------------------------ |
| –°—Ä–µ–¥–Ω–µ–µ (mean)  | –£—Å—Ä–µ–¥–Ω—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö    |
| –î–∏—Å–ø–µ—Ä—Å–∏—è (var) | –ù–∞—Å–∫–æ–ª—å–∫–æ –¥–∞–Ω–Ω—ã–µ —Ä–∞–∑–±—Ä–æ—Å–∞–Ω—ã    |
| –°—Ç. –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ  | –ö–æ—Ä–µ–Ω—å –∏–∑ –¥–∏—Å–ø–µ—Ä—Å–∏–∏            |
| –ö–æ–≤–∞—Ä–∏–∞—Ü–∏—è      | –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –º–µ–∂–¥—É –¥–≤—É–º—è —Ñ–∏—á–∞–º–∏ |
| –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è      | –ù–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–≤–∞—Ä–∏–∞—Ü–∏—è       |

–≠—Ç–æ –≤—Å—ë ‚Äî –±–∞–∑–æ–≤—ã–µ –∫–∏—Ä–ø–∏—á–∏–∫–∏ —Ä–µ–≥—Ä–µ—Å—Å–∏–∏ –∏ –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏.

```go

import (
	"fmt"

	"gonum.org/v1/gonum/stat"
)

func main() {
	data := []float64{5, 7, 8, 9, 10, 6}

	mean := stat.Mean(data, nil)
	variance := stat.Variance(data, nil)
	sdt := stat.StdDev(data, nil)

	fmt.Println("–î–∞–Ω–Ω—ã–µ:", data)
	fmt.Println("–°—Ä–µ–¥–Ω–µ–µ:", mean)
	fmt.Println("–î–∏—Å–ø–µ—Ä—Å–∏—è:", variance)
	fmt.Println("–°—Ä–µ–¥–Ω–µ–∫–≤–∞–¥—Ä–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ:", sdt)

	x := []float64{1, 2, 3, 4, 5}
	y := []float64{2, 4, 6, 8, 10}

	cov := stat.Covariance(x, y, nil)
	corr := stat.Correlation(x, y, nil)

	fmt.Printf("\n–ö–æ–≤–∞—Ä–∏–∞—Ü–∏—è(x, y): %.2f\n", cov)
	fmt.Printf("–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è(x, y): %.2f\n", corr)
}
```
---

### üîπ –£—Ä–æ–∫ 5: –õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è ‚Äî —Ç–µ–æ—Ä–∏—è –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å –Ω—É–ª—è

---

#### üìò –¢–µ–æ—Ä–∏—è:

**–õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è** –∏—â–µ—Ç **–ø—Ä—è–º—É—é**, –∫–æ—Ç–æ—Ä–∞—è **–ª—É—á—à–µ –≤—Å–µ–≥–æ –æ–ø–∏—Å—ã–≤–∞–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å** –º–µ–∂–¥—É –≤—Ö–æ–¥–æ–º `x` –∏ –≤—ã—Ö–æ–¥–æ–º `y`:

$$
y = w \cdot x + b
$$

–ì–¥–µ:

* `w` ‚Äî –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –Ω–∞–∫–ª–æ–Ω–∞ (–≤–µ—Å),
* `b` ‚Äî —Å–º–µ—â–µ–Ω–∏–µ (bias, –∏–Ω—Ç–µ—Ä—Å–µ–ø—Ç).

---

### üìê –¶–µ–ª—å: –Ω–∞–π—Ç–∏ —Ç–∞–∫–∏–µ `w` –∏ `b`, —á—Ç–æ–±—ã –º–∏–Ω–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å **—Å—É–º–º—É –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ –æ—à–∏–±–æ–∫**:

$$
\text{Loss} = \frac{1}{n} \sum_{i=1}^{n} (y_i - (w \cdot x_i + b))^2
$$

–ú—ã –º–æ–∂–µ–º –≤—ã—á–∏—Å–ª–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã **–∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏** (–±–µ–∑ –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ —Å–ø—É—Å–∫–∞), –∏—Å–ø–æ–ª—å–∑—É—è **–º–∞—Ç—Ä–∏—á–Ω—É—é —Ñ–æ—Ä–º—É–ª—É**:

$$
\theta = (X^T X)^{-1} X^T y
$$

–ì–¥–µ:

* `X` ‚Äî –º–∞—Ç—Ä–∏—Ü–∞ –≤—Ö–æ–¥–æ–≤ (–¥–æ–±–∞–≤–∏–º —Å—Ç–æ–ª–±–µ—Ü –µ–¥–∏–Ω–∏—Ü –¥–ª—è `b`),
* `y` ‚Äî –≤–µ–∫—Ç–æ—Ä —Ü–µ–ª–µ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π,
* `Œ∏` ‚Äî –≤–µ–∫—Ç–æ—Ä –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ (`[b, w1, w2, ...]`).

---

### üíª –ü—Ä–∏–º–µ—Ä –∫–æ–¥–∞: –ª–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è –≤—Ä—É—á–Ω—É—é

```go
import (
	"fmt"

	"gonum.org/v1/gonum/mat"
)

func LinearRegression(xData, yData []float64) *mat.VecDense {
	nSamples := len(xData)

	x := mat.NewDense(nSamples, 2, nil)
	for i := 0; i < nSamples; i++ {
		x.Set(i, 0, 1)
		x.Set(i, 1, xData[i])
	}

	y := mat.NewVecDense(nSamples, yData)

	var xT mat.Dense
	xT.CloneFrom(x.T())

	// X^T * X
	var xTx mat.Dense
	xTx.Mul(&xT, x)

	// (X^T * X)^-1
	var xTxInv mat.Dense
	err := xTxInv.Inverse(&xTx)
	if err != nil {
		panic("–ú–∞—Ç—Ä–∏—Ü–∞ –Ω–µ –æ–±—Ä–∞—Ç–∏–º–∞")
	}

	// X^T * y
	var xTy mat.VecDense
	xTy.MulVec(&xT, y)

	// Œ∏ = (X^T X)^-1 X^T y
	var theta mat.VecDense
	theta.MulVec(&xTxInv, &xTy)

	return &theta
}

func main() {
	x := []float64{1, 2, 3, 4, 5}
	y := []float64{2, 4, 6, 8, 10} // y = 2x, –æ–∂–∏–¥–∞–µ–º w=2, b=0

	theta := LinearRegression(x, y)

	for _, xi := range x {
		yPred := theta.AtVec(0) + theta.AtVec(1)*xi
		fmt.Printf("x=%.1f ‚Üí y_hat=%.2f\n", xi, yPred)
	}

	fmt.Printf("–†–µ–∑—É–ª—å—Ç–∞—Ç –ª–∏–Ω–µ–π–Ω–æ–π —Ä–µ–≥—Ä–µ—Å—Å–∏–∏:\n")
	fmt.Printf("b (intercept): %.2f\n", theta.AtVec(0))
	fmt.Printf("w (–∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç): %.2f\n", theta.AtVec(1))
}

```
---

## üîπ –£—Ä–æ–∫ 6: –ú–Ω–æ–≥–æ–º–µ—Ä–Ω–∞—è –ª–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è + –ú–∏–Ω–∏-–ø—Ä–æ–µ–∫—Ç

---

### üìò –¢–µ–æ—Ä–∏—è:

–î–æ —ç—Ç–æ–≥–æ —Ç—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –ø—Ä–∏–∑–Ω–∞–∫ `x`. –ê –µ—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤, –Ω–∞–ø—Ä–∏–º–µ—Ä:

```
y = b + w1*x1 + w2*x2 + ... + wn*xn
```

–ú—ã –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—É –∂–µ —Ñ–æ—Ä–º—É–ª—É:

$$
\theta = (X^T X)^{-1} X^T y
$$

–≥–¥–µ `X` ‚Äî —Ç–µ–ø–µ—Ä—å –º–∞—Ç—Ä–∏—Ü–∞ —Å **n –ø—Ä–∏–∑–Ω–∞–∫–∞–º–∏ + 1 —Å—Ç–æ–ª–±–µ—Ü 1 –¥–ª—è —Å–º–µ—â–µ–Ω–∏—è**.

---

### üíª –ü—Ä–∏–º–µ—Ä: –º–Ω–æ–≥–æ–º–µ—Ä–Ω–∞—è –ª–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è

–î–æ–ø—É—Å—Ç–∏–º, –º—ã —Ö–æ—Ç–∏–º –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞—Ç—å —Ü–µ–Ω—É –º–∞—à–∏–Ω—ã –ø–æ:

* –ø—Ä–æ–±–µ–≥—É,
* –≤–æ–∑—Ä–∞—Å—Ç—É.

```go
package main

import (
	"fmt"
	"gonum.org/v1/gonum/mat"
)

func LinearRegression(Xdata [][]float64, Ydata []float64) *mat.VecDense {
	nSamples := len(Xdata)
	nFeatures := len(Xdata[0])

	X := mat.NewDense(nSamples, nFeatures+1, nil)

	// –§–æ—Ä–º–∏—Ä—É–µ–º –º–∞—Ç—Ä–∏—Ü—É X —Å bias (–µ–¥–∏–Ω–∏—Ü–∞ –≤ –ø–µ—Ä–≤–æ–º —Å—Ç–æ–ª–±—Ü–µ)
	for i := 0; i < nSamples; i++ {
		X.Set(i, 0, 1) // Bias
		for j := 0; j < nFeatures; j++ {
			X.Set(i, j+1, Xdata[i][j])
		}
	}

	y := mat.NewVecDense(nSamples, Ydata)

	var xT mat.Dense
	xT.CloneFrom(X.T())

	var xTx mat.Dense
	xTx.Mul(&xT, X)

	var xTxInv mat.Dense
	err := xTxInv.Inverse(&xTx)
	if err != nil {
		panic("–ú–∞—Ç—Ä–∏—Ü–∞ –Ω–µ –æ–±—Ä–∞—Ç–∏–º–∞")
	}

	var xTy mat.VecDense
	xTy.MulVec(&xT, y)

	var theta mat.VecDense
	theta.MulVec(&xTxInv, &xTy)

	return &theta
}

func main() {
	X := [][]float64{
		{10, 5}, // 10 —Ç—ã—Å. –∫–º, 5 –ª–µ—Ç
		{20, 3},
		{30, 2},
		{40, 1},
	}
	Y := []float64{10000, 12000, 14000, 16000} // –¶–µ–Ω–∞

	theta := LinearRegression(X, Y)

	fmt.Printf("–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã (Œ∏):\n")
	for i := 0; i < theta.Len(); i++ {
		fmt.Printf("Œ∏[%d]: %.2f\n", i, theta.AtVec(i))
	}
}
```
